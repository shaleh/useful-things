#!/usr/bin/env python

####################################################################################
# Copyright (c) 2013, Sean Perry <shaleh@speakeasy.net>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer.
#
# Redistributions in binary form must reproduce the above copyright notice, this
# list of conditions and the following disclaimer in the documentation and/or
# other materials provided with the distribution.
#
# Neither the name of the {organization} nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
####################################################################################


import argparse
import inspect
import random
import string
import sys


class PasswordFailure(Exception):
    pass


class ContainsItemPredicateBase(object):
    def __init__(self, allowed, failure):
        self.allowed = allowed
        self.failure = failure

    def __call__(self, word):
        return any(c in self.allowed for c in word)


class ContainsLetterPredicate(ContainsItemPredicateBase):
    def __init__(self):
        super(self.__class__, self).__init__(string.ascii_letters, "Does not contain a letter")


class ContainsNumberPredicate(ContainsItemPredicateBase):
    def __init__(self):
        super(self.__class__, self).__init__(string.digits, "Does not contain a number")


class ContainsSymbolPredicateSpecial(ContainsItemPredicateBase):
    def __init__(self):
        super(self.__class__, self).__init__('+!@#$&', "Does not contain a symbol")


class StartsWithLetterPredicate(object):
    allowed = ''
    failure = "Does not start with a letter"

    def __call__(self, word):
        return word[0] in string.ascii_letters


def check_symbols(input):
    all_valid_symbols = "!@#$%^&*_+?"

    if all(c in all_valid_symbols for c in input):
        return input

    raise argparse.ArgumentTypeError("{} is not a valid list of symbols. Please use {}".format(input, all_valid_symbols))


def follows_rules(rules, password):
    for rule in rules:
        if not rule(password):
            raise PasswordFailure(rule.failure)

    return True


def instantiate_rules():
    return [p() for name, p in inspect.getmembers(sys.modules[__name__], inspect.isclass) if name.endswith('Predicate')]


def new_password(allowed, length):
    result = "".join(random.choice(allowed) for i in range(length))
    return result


def run_new_password(password_length, allowed, rules, verbose):
    try:
        result = new_password(allowed, password_length)
        follows_rules(rules, result)
        return result
    except PasswordFailure, e:
        if verbose:
            print e

    return None


if __name__ == '__main__':
    symbol_predicate = ContainsSymbolPredicateSpecial()

    parser = argparse.ArgumentParser(description='Generate a new password following rules.')
    parser.add_argument('--verbose', action='store_true', help='be verbose')
    parser.add_argument("--symbols", default=symbol_predicate.allowed, type=check_symbols, help="allowed symbols")
    parser.add_argument('password_length', type=int, help='how long does the password need to be?')

    args = parser.parse_args()

    symbol_predicate.allowed = args.symbols

    rules = instantiate_rules()

    if symbol_predicate.allowed:
        rules.append(symbol_predicate)

    allowed = ''.join(rule.allowed for rule in rules)

    count = 0
    keep_trying = True
    while keep_trying:
        count += 1

        result = run_new_password(args.password_length, allowed, rules, verbose=args.verbose)
        if result:
            keep_trying = False

            if args.verbose:
                print "{} tries required".format(count)

            print result
